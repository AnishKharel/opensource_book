<?xml version="1.0" encoding="UTF-8"?>

<section xml:id="sec_dev_basic_shell_commands">
  <title>Basic Shell Commands</title>
  <introduction>
  <p>
    In this section, we will explore shell commands related to files, directories, and navigation.
  </p>
  <p>
    Disclaimer: It is beyond the scope of this book to cover anything but the minimum of shell commands needed for contributions to open source, so the subsections below cover only the bare essentials.
  </p>
  </introduction>

<subsection xml:id="subsec-files_directories_privileges">
  <title>Files, Directories, and Privileges</title>
  <p>
    This and subsequent subsections are written to be followed as an extended exercise with explanations given as we go.
  </p>
    <exercise xml:id="exercise-try-cli">
    <title>Exercise: Try shell commands for navigation</title>
    <p>Try each of the following commands on your own machine.</p>
  </exercise>
      <p>
      First, follow the directions given in <xref ref="subsec-getting_terminal"/> to open a terminal window so you can use your shell. All of the shell commands will be typed in this terminal window.
      </p>
      <p> Linux is designed as a multi-user system, so there are users. If you type the following shell command:
    </p>
    <pre>
    whoami
    </pre>
    <p>
      The shell should respond with the username that you created when you set up your system.  For me that is <c>pearcej</c>. 
    </p>

    <p>
      Note that the shell is <term>case sensitive</term>, which means that it discriminates between uppercase and lowercase letters, so two words that in letter cases only, are not considered equal. This means that neither <c>WhoAmI</c> nor <c>WHOAMI</c>  are shell commands, so will likely elicit a response like:
      </p>

      <pre>
        WhoAmI: command not found
      </pre>

    <paragraphs>
      <title>Directories</title>
      <p>
        
      </p>
    <p> 
      A <term>file</term> is just a container for storing information. On a phone or in a GUI, we see typically see files as icons with the filename below or to the right. We might (or might not) be used to using folders to organize our files and to navigate the file system. (On an Iphone or Android phone, you make a new folder by dropping one app on top of another app, on a Mac you long press and then choose new folder, and on a Windows machine, you right-click and choose New > folder.) This type of organization is important to understand, and the folder metaphor is useful. In fact, there are two useful metaphors or mental models to help with our understanding of file systems. Note that when using the shell, these "folders" are more typically called <term>directories</term>, but using the "folder" as your mental model for a directory will be very effective. This mental model tells us that inside of a directory, we can find files and possibly additional directories. Technically speaking, a directory is actually just a file that contains a list of other files, so you will see the both files and directories presented similarly by the shell. Using a different metaphor, you can think of all of the directories in your entire system as forming a tree structure which grows downward from a single directory which is known as the <term>root directory</term>. In other words, the top level directory which is the parent of all directories is called the 'root' directory. It is referenced by the use of forward slash symbol (<term>/</term>) when the forward slash symbol is used alone (or at least with nothing prepended in front of it). (As a comparison, the root directory notation in a standard Windows set-up is the C: directory.)  
    <notation>
      <usage><m>/</m></usage>
      <description>root directory symbol</description>
    </notation>
  </p>
      <p>First, let's get our bearings and see which directory we are currently in. The <c>pwd</c> command stands for <em>print working directory</em> and as the name says it prints the name of the directory you are working in. Try typing:
      </p>
      <pre>
      pwd
      </pre>
      <p>
      When I type this, I see the following:
    </p>
    <pre>
    /home/pearcej
    </pre>
      <p>
        Reading from right to left, this means I am in a <term>child</term> directory named <c>pearcej</c> which itself is a child of a directory called <c>home</c> which is itself a child of the root directory. If you prefer the folder metaphor to the tree metaphor, you can think of <c>pearcej</c> as being "inside" of the <c>home</c> directory, which is inside of the root directory. Note that the position with respect to the forward slash '/' tells us the direction of the relationship â€“ further to the right is further "inside".  
      </p>
      <p>
       Let's try "moving" (i.e. changing our working directory) to the root directory. Use the <c>cd</c> command which stands for <em>change directory</em> followed by the <c>/</c> by typing:
      </p>
      <pre>
      cd /
      </pre>
      <p>
      What you just did should have transported you to the <term>root directory</term> (if you weren't there already.) Now when you use <c>pwd</c>, you should see <c>/</c> echoed back. Note that the term <em>root directory</em> shouldn't be confused with the term <em>root user</em> in a Linux-like system. The <term>root user</term> is a user named <em>root</em>, which is a special superuser account in Linux operating systems that has unrestricted read and write privileges to everything. The <em>root directory</em> should also not be confused with the <c>/root</c> folder which found on some Linux-based OS's, which is the home directory of the root superuser. (More about this later.)
      </p>

      <p>
      Next type the following <c>ls</c> to get a <em>listing</em> of the files and subdirectories in the <em>root directory</em>.
      </p>
      <pre>
      ls
      </pre>
      <p>
      Many shell commands have options which can be invoked by using a <term>flag</term> or <term>command option</term>. 
        Try typing the following where the <c>-r</c> flag stands for <c>reverse</c>, and it reverses the sorting order:
      </p>
      <pre>
      ls -r
      </pre>
      <p>
      To try another, try typing the following where the <c>-l</c> option stands for <em>long listing format</em>, meaning that instead of output containing only a names of files and directories the ls command will produce additional information, assuming you have at least one file or directory.
      </p>
          
<pre>
ls -l
</pre>
<p>
  You are likely to see some lines that look something like this:
</p>
<pre>
drwxr-xr-x  3 root    root     4096 Jun 19 10:55 home
lrwxrwxrwx  1 root    root        7 Mar 24  2022 bin -> usr/bin
-rw-rw-r--  1 pearcej friends    22 Sep 15  2022 hello.txt
</pre>
   </paragraphs>
   <paragraphs>
    <title>File Permissions</title>
<p>
</p>
<p>
  Let's explore the permissions portions of the lines produced by the <c>ls -l</c> command. The last item on each of these lines is the filename itself. The first item in each of the lines is a 10 character-long mix of letters and minus signs. The first character of that set indicates the file type where <c>d</c> tells us it is a directory, <c>l</c> indicates it is a symbolic link, and <c>-</c> indicates it is a regular file. The next nine characters display various permissions for the file. The first set of three characters (characters 2-4) are the user's (i.e. the file owner's) permissions, the next three are the group's permissions, and the last three are the permissions for all others. (The user's name  is in the third column and the group name is in the fourth column.) In each of these sets of three characters, the three characters refer to read (<c>r</c>), write (<c>w</c>), and execute (<c>x</c>) respectively. If you see a letter then that permission is allowed, and if you see a '-', the permission is disallowed. For example in the last of the three lines shown above, we see that the file <c>hello.txt</c> has permissions of <c>-rw-rw-r--</c>. This means this is a file that can be read and written (changed) but not executed by the owner <c>pearcej</c> and also by any user who is a member of the <c>friends</c> group, however other users can only read the file.
</p>
<p>
  Occasionally, you need to change permissions of a file. For example, you might need to change permissions to make a file executable. Changing file permissions is done with the <c>chmod</c> command. We will explore this in a bit.
</p>
   </paragraphs>

   <paragraphs>
    <title>Shell Command Options</title>
    <p>
    </p>
  <p>
    If you want to see all of the flag options there are two different methods for most commands. You can use the <c>--help</c> flag option on the command or you can use the <term>manual</term> which is accessed using the <c>man</c> command. For example, with the <c>ls</c> command, you can use either one of the following, noting that they work a bit differently because the manual may use paging. If it does, to go to the next page use the space bar.
  </p>
      <pre>
      ls --help
      man ls
      </pre>
      <p>
        You may be wondering about the use of one minus sign '-' vs the use of two minus signs '--' in shell flags. One minus sign is used for single letter commands, while two is used for word-length commands. If you look back at the <c>ls --help</c> results, you may see that the flags <c>-a</c> and <c>--all</c> both list all files including that begin with a '.', which are the hidden files  and directories. Besides brevity, the main advantage to the single minus sign is that to run multiple options at the same time, all you need to do is concatenate them, so <c>ls -lra</c> would return the result with  the <c>-l</c>,  <c>-r</c>, and <c>a</c> option flags all activated. Give it a try!
      </p>
      <pre>
      ls -lra
      </pre>
  </paragraphs>
  <paragraphs>
    <title>More on Directories</title>
    <p>
    </p>
        <p>
        Next, let's go to your <term>home</term> directory which is referenced by the special tilde '~' character as follows:
      <notation>
      <usage><m>\tilde{}</m></usage>
      <description>home directory symbol</description>
    </notation>
      </p>
    <pre>
   cd ~
    </pre>
      <p>
        Then print your working directory and list your files just to see that you have been transported again. 
      </p>

      <p>
        You can make a new directory using the <c>mkdir</c> command. For example, let's say you want to make a new directory with the name <em>newdir</em>, you can type the following:
        </p> 
        <pre>
         mkdir newdir
        </pre>
        <p>
          If you get a listing of your files and directories with <c>ls -l</c>, you should see something like the following:
        </p>
        <pre>
        drwxr-xr-x  2 pearcej pearcej   4096 Nov 15 17:00 newdir
        </pre>
        <p>
          Then you can descend into the new directory with:
      </p>
        <pre>
          cd newdir
        </pre>
      <p>
        Of course if you now run the <c>ls</c> command, you will not see any files, but try it with the following options:
      </p>
    <pre>
      ls -la
    </pre>
      <p>
        You are likely to see something like the following:
      </p>
    <pre>
  drwxr-xr-x  2 pearcej pearcej 4096 Nov 16 17:00 .
  drwxr-xr-x 13 pearcej pearcej 4096 Nov 16 17:00 ..
    </pre>
      <p>
      Note the period at the end of the first line where the filename is expected. A period or dot '.' represents the current directory. The double period or double dot '..' represents the parent directory of the current one.
      <notation>
      <usage><m>.</m></usage>
      <description>current directory symbol</description>
    </notation>
      <notation>
      <usage><m>..</m></usage>
      <description>parent directory symbol</description>
    </notation>
  </p>
  <p>
      You can use this dot notation as a reference as well, so <c>ls ..</c>, will list all the files and directories in the parent directory relative to where you are so you don't have to change directories to get the listing from another directory. Try it!
    </p>
    <p>
    You can even use these dots in combination with folder names.


    For example, if you are inside of the <c>newdir</c> directory and you want to make a sibling directory called <c>newdir2</c>, you can type the following:
    </p>
   <pre>
   mkdir ../newdir2
   ls -l ..
   </pre>
  <p>
    Here, the first command says, go up one level in the directory tree structure, and create a new directory one level below that, which makes it a sibling of the original <c>newdir</c> directory. The second lines says produce a long listing of all of the files and directories in the directory that is one level up relative to where I am. 
    You should see both of the directories that you made. 
    </p>
    <p>
    If you want to delete either of these new directories, you will need to use the <term>remove directory</term> command, <c>rmdir</c> followed by the name of the directory you want to remove. Try it!
  </p>

  </paragraphs>
  <paragraphs>
    <title>Files</title>
    <p>
    </p>
    <p>
    There are a number of ways one can create a new file from the shell. Let's try a few. First, use <c>cd</c> to descend into one of your new directories, if you are not already in one, and type <c>ls</c>. You should be in an empty directory. Then let's try the following commands:
       <pre>
 touch newfile1.txt
 echo 'I love open source!' > newfile2.txt
 echo 'I really love open source!' >> newfile3.txt
 ls
   </pre>
   You should now see three new files named <em>newfile1.txt</em>, <em>newfile2.txt</em>, and <em>newfile3.txt</em> respectively. The <c>touch</c> command simply makes an empty file, so the first line we typed is pretty straightforward. The second and third lines that we typed require a bit more explanation. The <c>echo</c> command simply echoes the argument(s), so if we had just typed <c> echo 'I love open source!'</c>, then  'I love open source!' would be repeated on the screen (without the quotation marks.) This might not seem very useful, but it is widely used in shell scripts to output status text or variable values to the screen or to a file. Both <c>></c> and <c>>></c> are used to redirect the output to someplace other than the screen.</p>

   <p>
    At first glance, the <c>echo</c> command might not seem very useful. One typical use is to echo the values of a variety of variables including environment variables, which are variables that are part of the environment in which a process runs. For example, typing the following will print the value of the home directory followed by the value of the working directory on the screen:
   </p>

   <pre>
   echo $HOME
   echo $PWD
   </pre>

    <p><term>Output redirection</term> with <c>></c> or <c>>></c> is a feature in the shell that allows to change the standard input/output devices. The standard input device is the keyboard, and the standard output device is the screen, but sometimes we want to change this. With output redirection, the above standard output can be changed to go into a file, and that is exactly what we did above. Note that the <c>></c> is the output redirection operator used for <em>overwriting</em> files that might or might not already exist in the directory, while the <c>>></c> is an output operator that appends the data of an existing file (or creates a new file by that name if one did not already exist.) So, <c>></c> should be used judiciously.
    </p>
  
    <p>
      Let's look at the contents of the files that we created. The <c>cat</c> command, which stands for <em>concatenate</em>, is used to concatenate standard input (typically the keyboard) or file(s) to the standard output (typically the screen). To use <c>cat</c> to see the file contents, type the following one at a time:
       <pre>
cat newfile1.txt
cat newfile2.txt
cat newfile3.txt
   </pre>
Like the name suggests, you can also use the <c>cat</c> command to concatenate files. For example, if you try:
       <pre>
cat newfile2.txt newfile3.txt > newfile1.txt
cat newfile1.txt
   </pre>

  You should see that <em>newfile1.txt</em> instead of being empty, now contains the concatenation of <em>newfile2.txt</em> and <em>newfile3.txt</em> 
    </p>
<p>
  You can also use the <c>cat</c> command in combination with output redirection to create a multi-line file as follows:
</p>
<pre>
cat >> newfile_multi.txt
these
are
multiple
lines
</pre>


  <p>
    The  shell command <c>wc</c>, which stands for <em>word count</em>, is a command that s the name suggests can be used for counting. However, it does more than count words! It actually provides the line count, the word count, and the character count in the file(s) specified in the file arguments.
    By default, it displays all this in four-columnar output with the file name in the final column.
    
    Let's try this command with <em>newfile2.txt</em>.
  </p>  

<pre>
wc newfile2.txt
</pre>

<p>
Will reply with <c>1  4 20 newfile2.txt</c> because the contents of <em>newfile2.txt</em> is 'I love open source!' which is 1 line, 4 words, and 20 characters.
</p>
<!-- 
<p>
  Another way to create a file in bash is with a strangely named command called the <term>here document</term>, which I suppose you can think of as creating a document in the current directory (here).  It has the form of <c><COMMAND < TERMINATOR/c>, where COMMAND can be any bash command and TERMINATOR is a string deliminator that indicates the end of an input list. Clearly, we need an example for this one.  Type the following into your shell:
 </p> 
<pre>
cat << _end_
this
is
a
list
_end_
</pre>
<p>
You should see the list of words echoed back to you on the screen. However, we can redirect the output into a file as follows:
</p>
<pre>
cat << _end_ > newfile_here.txt
this
is
a
list
_end_
</pre>

<p>
  Here documents are our first example of a kind of input redirection because we have redirected the command's input using the '<<' so the command takes a list that we create from the keyboard as its parameter.
</p>
   -->
  <p>
  Analogous to output redirection, <term>input redirect</term> in the  shell using <c> &gt; </c> or <c>&gt;&gt;</c> allows you to redirect the input of a command. 
  <!-- Unlike the here document example, often you will redirect to use a file instead of the keyboard.  -->
  So, if we want the response from a command to be written to a file instead of to the screen, we can use input redirection. Let's look at an example using the <c>sort</c> command, which is used to sort lines in a file.
</p>
<p>
 TODO: need a good example of input redirect that is needed, not just an option.
</p>

<p>
  A <term>pipe (|)</term> in the bash shell allows you to redirect the output of one command as the input of another command. Let's see an example:
</p>

<pre>
  TODO: need a good example of input redirect that is needed, not just an option.
</pre>

<p>
  It is possible to use what we have learned thus far to make an executable script. Let's type the following followed by a control-C:
</p>

<pre>
  cat >> helloworld.sh
  # This is a comment in a bash script that displays Hello World!
  echo 'Hello World!'
</pre>

<p>
  You should now have a file that needs to be made executable. To do this we use the <c>chmad</c> command with the <c>+x</c> option, which stands for 'add execution' as follows:
</p>

<pre>
  chmod +x helloworld.sh
</pre>

<p>
  To run this script, you need to indicate the directory where to find it, which is the current directory. So, to run it, you can type the following:
</p>
<pre>
./helloworld.sh
</pre>

<p>
  We can create a more interactive bash script using the <c>read</c> command which reads text from the keyboard or other standard input. It can be used to make scripts interactive. To do this, we need a variable. In the bash shell, some variables, like environment variables, always exist and you can always access them. 
  However, you can also create your own variables. You can always use echo to see the value a variable, but you must precede the variable name with the dollar sign ($). Let's see how all this works by trying the following, finishing with a Control-C:
</p>

<pre>
  cat >> hellouser.sh
  # This is a comment in an interactive bash script that says hello to the user by name.
  echo 'What is your name?'
  # In the following, USERNAME is a new variable that is created dynamically
  read USERNAME
  echo "Hello " $USERNAME
</pre>

<p>
  To run this script, you will again need to make it executable.  Then you can run it.
</p>

<pre>
  chmod +x hellouser.sh
  ./hellouser.sh
</pre>
<p>


    We can also move files around, make a copy of files, or remove (delete) files from the filesystem using <c>mv</c>, <c>cp</c>, and <c>rm</c> respectively. Let's see how these work. First, list your files. You should have  <em>newfile1.txt</em>, <em>newfile2.txt</em>, and <em>newfile3.txt</em> in your directory. </p>
      <p>
        Let's make a new directory below our current directory and move one of our files there.
       <pre>
mkdir subdir
mv newfile3.txt subdir/newfile3.txt
ls
ls subdir
   </pre>
You should see that newfile3.txt is now not in the current directory, but it is instead in the subdirectory 
<em>subdir</em>.
</p>
  <p>
    In addition to moving files around in the directory structure, we can also use the <c>mv</c> command to rename files as follows:

    <pre>
mv newfile1.txt newfile4.txt
 ls 
   </pre>
   One important thing to watch out for with the <c>mv</c> command is that if the destination filename already exists, it might get overwritten. For this reason, you might want to use the <c>-i</c> flag which stands for interactive. Try it.
    <pre>
mv -i newfile1.txt newfile2.txt
</pre>
You should see a question like, "overwrite 'newfile2.txt'?"If you respond with "n", then the file will not be overwritten.
  </p>
<p>
The <c>cp</c>command works as you might expect:

    <pre>
cp newfile2.txt newfile2_cp.txt
cat newfile2_cp.txt
   </pre>
Just like with the <c>mv</c>, command the <c>cp</c> command will overwrite the destination file if it already exists. For this reason, you might want to use the <c>-i</c> flag which stands for interactive. Try it.
    <pre>
mv -i newfile4.txt newfile2_cp.txt
</pre>
You should see a question like, "overwrite 'newfile2_cp.txt'?" If you respond with "n", the command will not overwrite, so using the <c>-i</c> flag seems a wise safeguard.
</p>
<p>
  The <c>rm</c> command is a useful, but another dangerous command.  Let's try it:
<pre>
rm newfile2_cp.txt
</pre>

Just as with <c>cp</c>, and <c>mv</c>, you are probably wise to use the <c>-i</c> option. 
<pre>
rm -i newfile4.txt
</pre>
And, if you respond with "n", then the removal will not happen. 
</p>
  </paragraphs>
<paragraphs>
  <title>A few time-saving shell commands</title>
  <p>
    
  </p>
  <p>
    The <em>up arrow</em> key retrieves the previous shell command. If you press it multiple times, it will take you back through multiple commands in your shell history. This is a useful way to repeat a command. For example, if you had a typo, you can use the up arrow, edit the command, and push enter to fix the command. Analogously, the <em>down arrow</em> will move you in the reverse direction through the shell command history. For more useful shell commands, type <c>man bash</c> for hints on how to search your shell history, re-execute commands, and much more.
    </p>
  <p>
    Another thing that is very useful in the shell is the use of regular expressions. A regular expression (aka regex) is a sequence of characters that specifies a text search pattern. Regular expressions are quite powerful, and it is not within the scope of this textbook to teach them, instead this paragraph is intended to alert you to how useful they can be. A couple examples of very common regular expressions pattern symbols are the question mark and the asterisk.  The question mark (?) specifies any single character to match, and the asterisk (*) specifies zero or more characters to match.</p>
      <p>
        For example, if we type the following:
        <pre>
rm -i newfile?.txt
</pre>
Then the question mark will match with any single character, and we will see the following prompts:
<pre>
rm: remove regular file 'newfile2.txt'?
rm: remove regular file 'newfile4.txt'?
</pre>
If we instead type:
<pre>
rm -i newfile*.txt
</pre> 
    Then the asterisk will match with any number of characters (including zero), and we will see the following prompts:
<pre>
rm: remove regular file 'newfile2.txt'?
rm: remove regular file 'newfile4.txt'?
rm: remove regular file 'newfile2_cp.txt'?
</pre>
As you can see, regular expressions give you a lot of power and control. 
  </p>

  
  </paragraphs>

</subsection>

<conclusion>
<title>Conclusion</title>
  <p>
    Hopefully, you feel a bit more comfortable using the shell from the command line. The shell commands discussed above are summarized in Appendix <xref ref="ap_shell_cheat_sheet"/>.
  </p>
</conclusion>

</section>

