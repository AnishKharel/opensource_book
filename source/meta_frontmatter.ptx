<?xml version="1.0" encoding="UTF-8"?>
<!-- This frontmatter division contains all content before the -->
<!-- first chapter.  -->


<frontmatter xmlns:xi="http://www.w3.org/2001/XInclude" xml:id="meta_frontmatter">
  <titlepage>
    <author>
      <personname>Dr. Jan Pearce</personname>
      <department>Computer Science</department>
      <institution>Berea College</institution>
    </author>
    <date><today/></date>
  </titlepage>

  <colophon>

    <website>
      <name><c>my-website.org</c></name>
      <address>http://pretextbook.org</address>
    </website>

    <copyright>
      <!-- In addition to specifying the copyright holder, you should  -->
      <!-- include a license, such as the cc-by-sa license shown below -->
      <!-- so people reading your book know how they can use it.       -->
      <year>2020<ndash/>2022</year>
      <holder>Dr. Jan Pearce</holder>
      <!-- <minilicense><image source="../images/by-sa.png" /></minilicense> -->
      <shortlicense>
        <!-- <image source="../images/by-sa.png" width="15%"/>  -->
        This work is provisionally licensed under the Creative Commons Attribution-ShareAlike 3.0 International License.
        To view a copy of this license, visit
        <url 
          href="http://creativecommons.org/licenses/by-sa/3.0/"
          visual="creativecommons.org/licenses/by-sa/3.0">
          CreativeCommons.org
        </url>
      </shortlicense>
    </copyright>

  </colophon>

  <dedication>
    <p>
      For everyone who wants to learn to contribute to open source projects.
    </p>
  </dedication>

  <acknowledgement>
    <p>
      I would like to thank Berea College for sabbatical support that gave me time and made this work possible. If you do not already know about Berea College, you might be interested to know 
      I am also grateful to the software innovation lab <url href="https://www.tweag.io" visual="tweag.io">Tweag</url> for financial support and my Tweag mentor, Michael Gale's time.
    </p>
    <p>
      Several parts of this textbook including the Forward and several portions of chapters 1 and 2 are modified from Karsten Wade's quiad.fedorapeople.org site <url href="https://quaid.fedorapeople.org/TOS/Practical_Open_Source_Software_Exploration/html/" visual="quaid.fedorapeople.org/TOS/Practical_Open_Source_Software_Exploration/html">Teaching Open Source</url>. We are very grateful to the authors Greg DeKoenigsberg, Chris Tyler, Karsten Wade, Max Spevack, Mel Chua, and Jeff Sheltren.
    </p>
    <p>
      Nearly all of Chapter 3 is modified from <url href="https://choosealicense.com/" visual="choosealicense.com">Choose a License</url> which is curated by <url href="https://github.com/" visual="github.com">. We are grateful for all that Github does for the open source community.
    </p>
  </acknowledgement>

  <preface xml:id="meta_frontmatter-preface">
    <!-- You should be a little careful about what you put here -->
    <!-- Avoid elements that should have a number, for example  -->
    <p>
      This textbook is designed for instructors, formal students, and self-learners. It explains what open source software is and teaches the basic skills of open source development incrementally, through real involvement in meaningful projects.
    </p>
  </preface>

  <!-- Note: You can have more than one preface. -->

  <preface xml:id="meta_frontmatter-forward">
    <title>Forward</title>
    <section xml:id="sec-why-necessary">
      <title>Why is This Book Necessary?</title>
      <p>
        In March 2006, David A. Patterson wrote an article entitled “Computer science education in the 21st century.” David A. Patterson was, at the time, the president of the Association for Computer Machinery, the world’s largest educational and scientific computing society. In this article — which, sadly, you cannot read unless you are an ACM member — he advocated for fundamental changes to how computer science is taught. One of the changes to the standard undergraduate computer science curriculum that he advocated for was the inclusion of courses in open source software development.
      </p>
      <p>
        One might think that such a clarion call, made by someone of such obvious influence, would generate a groundswell of enthusiasm. When the president of the ACM proclaims that it is “time to teach open source development,” the world of academia must certainly follow, yes?
      </p>
      <p>
        Its a little more complicated than that.
      </p>
      <p>
        We've spent a lot of time over the past few years talking to computer science professors. Mostly we’ve asked lots of questions — actually, the same ones over and over.
      </p>
      <p>
        <line>Do you use open source software in your classes? (Increasingly.)</line>
        <line>Are your students interested in open source? (Increasingly.)</line>
        <line>Do you or your students participate in open source software? (Rarely.)</line>
        <line>Do you teach open source development practices? (Almost never.)</line>
        <line>For these last two, the follow-up question is, invariably, “why not?”</line>
        </p>
      <p>
        And the answer is, invariably, “because its hard.”
      </p>
      <p>
        There are good reasons why professors don’t teach the practice of open source. It’s easy for open source advocates to explain away these reasons. At a certain point, though, one must accept the idea that most professors are well-intentioned, but bound by circumstances that make it frustratingly difficult to introduce students to open source development.
      </p>
      <p>
        So why bother?
      </p>
      <p>
        The answer is simple: the skills required to succeed in an open source software project are the exact same skills required to succeed in any large software project. The biggest difference is that, with just a bit of guidance, anyone can build their software skills in the open source world.
      </p>
      <p>
        We hope that this textbook helps provide that guidance to a whole generation of students.
      </p>
    </section>

    <section xml:id="sec-why-inneffective">
      <title>Why Traditional Student Projects Are Ineffective</title>
      <p>
        Almost every modern computer science degree program requires its students to complete a Big Project. Sometimes it’s the “Senior Project,” and sometimes it’s the “Capstone Project.” Whatever it’s called, the purpose of this Big Project is to expose students to “real” software engineering practices.
      </p>
      <p>
        In other words, this typically translates to “coding with other people.” Unfortunately, up until this point in a student’s education, this has usually been discouraged as “cheating.”
      </p>
      <p>
        The problem is that these Big Projects actually tend to focus on extremely bounded problems. Most of the time, a small team of students works on a small project for a semester, and the result is, quite naturally, a small project. While good learning can take place in a small project, it actually does very little to prepare students to work on Really Big Projects.
      </p>
      <p>
        To find Really Big Projects, one must venture out into the world, where there are Really Big Problems. The real world is full of gigantic applications that require build systems and revision control and defect tracking and prioritization of work. They are written in languages that one may or may not know, by people one may or may not ever meet. And in order to successfully navigate through these Really Big Projects, the novice developer must possess one skill above all others: the ability, in the words of our colleague David Humphrey, to be “productively lost.”
      </p>
      <p>
        The great advantage of open source, for the learner, is that the Really Big Projects of the open source world provide unparalleled opportunities to be productively lost. Complex codebases are immediately accessible by anyone who wants to participate. This accessibility is crucial to the learner, as participating in an activity is by far the most effective way to learn that activity.
      </p>
      <p>
        Sooner or later, the coder aspirant must work at scale, with teammates. Open source provides that opportunity in a way that nothing else can.
      </p>
    </section>
    <section xml:id="sec-using-this-textbook">
      <title> Using This Textbook to Get Started</title>
      <p>  
        This textbook exists because professors asked for it, but the textbook’s fundamental approach — teaching the basic skills of open source development incrementally, through real involvement in meaningful projects — should make it suitable for self-learners as well. Regardless of whether you are using this text as part of a course or working with it on your own, you should work through it while adhering to the principles of contributing, calling for help, and being bold.
      </p>
      <p>
        First, always be contributing. The majority of exercises in this textbook are designed to lead to direct and useful contributions to a project, no matter how small. Even a simple act, such as adding comments to a part of the code you don’t understand, can add real value to a project; that’s the great thing about community developed software. Contribution matters, and legitimate contributions, no matter how small, are always welcome.
      </p>
      <p>
        Second, call for help when you’re stuck. If you have trouble with an exercise — and at some point you will — look to your fellow contributors for help. Your chosen project has mechanisms for getting in touch with the more advanced developers: mailing lists, or IRC channels, or forums, or all of the above. Communicating with those around you is not only “not cheating,” it’s key to establishing greater understanding. Keep this in mind, though: in the real world, people are most likely to help those who are trying to help themselves. Before you ask someone a question on IRC, ask the same question of Google. A good rule of thumb: if you can’t figure something out in 15 minutes of searching the Internet, it’s reasonable to ask for a bit of help.
      </p>
      <p>
        And third, be bold. Try things. Break stuff. Don’t be afraid to play around with the code; it’s only code, after all, and if you break something, you can always revert to the previous version. If you reach a point at which you think you’re ready to make a contribution of some kind, then offer to help on the project mailing list. The answer will usually be “go ahead, thanks!” Sometimes the offer will be “no thanks, and here’s why,” and you’ll learn something. Occasionally the answer will be “no, go away,” which is also useful, since it tells you to invest your energies into another project. Sometimes the answer may be silence; don’t be afraid to keep asking until you get an answer, or even plunge ahead without one. Learn the rules of the project and follow them; if the rules of the project are vague or confusing, you can help to make them clear. This alone can be a critical contribution, as it clearly helps those who come along after you.
      </p>
      <p>
        In most educational contexts, you have likely been “trained” to wait for permission before doing anything not previously specified, but you must avoid letting that get in the way of your progress when engaging with an open source project. When the rules are unclear, don’t sit on your hands. Do your best to help the project. It’s better to do something wrong, and learn from it, than to do nothing at all.
      </p>
    </section>
    <section xml:id="sec-free-vs-opensource">
      <title> A Note on Terminology - Free Versus Open Source</title>
      <p>
        This is, first and foremost, a textbook about how to create software collaboratively, using a community development model.
      </p>
      <p>
        Some people call the result of such work by the name free software. Some people call it open source software. Some folks call it both: free and open source software. Some people throw in libre to specify a particular meaning of free, and call it free/libre open source software. Frequently one will see these abbreviated into the terms FOSS or FLOSS.
      </p>
      <p>
        There are valid reasons for the usage of these different terms in different contexts, but for the sake of simplicity, we use the term FOSS primarily in this book, with the tacit understanding that all terms mean virtually the same thing in our chosen context.
      </p>
      <p>
        Enough of the pep talk. Its time to get started.
      </p>
    </section>    
  </preface>
</frontmatter>

