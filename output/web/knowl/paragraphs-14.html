<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<section class="paragraphs"><h4 class="heading"><span class="title">A few time-saving shell commands.</span></h4>
<p></p>
<p>The <em class="emphasis">up arrow</em> key retrieves the previous shell command. If you press it multiple times, it will take you back through multiple commands in your shell history. This is a useful way to repeat a command. For example, if you had a typo, you can use the up arrow, edit the command, and push enter to fix the command. Analogously, the <em class="emphasis">down arrow</em> will move you in the reverse direction through the shell command history. For more useful shell commands, type <code class="code-inline tex2jax_ignore">man bash</code> for hints on how to search your shell history, re-execute commands, and much more.</p>
<p>Another thing that is very useful in the shell is the use of regular expressions. A <dfn class="terminology">regular expression</dfn> (aka <dfn class="terminology">regex</dfn>) is a sequence of characters that specifies a text search pattern. Regular expressions are quite powerful, and it is not within the scope of this textbook to teach them, instead this paragraph is intended to alert you to how useful they can be. A couple examples of very common regular expression patterns are using wildcards for zero or more characters or for a single character.  The asterisk (*) specifies zero or more characters to match. In bash the question mark (?) is used for matching exactly one single character, although this is not typical regex behavior.</p>
<p>For example, if we type the following:</p>
<pre class="code-block tex2jax_ignore">rm -i newfile?.txt
</pre>
<p>Then the question mark will match with any single character, and we will see the following prompts:</p>
<pre class="code-block tex2jax_ignore">rm: remove regular file 'newfile2.txt'?
rm: remove regular file 'newfile4.txt'?
</pre>
<p>If we instead type:</p>
<pre class="code-block tex2jax_ignore">rm -i newfile*.txt
</pre>
<p>Then the asterisk will match with any number of characters (including zero), and we will see the following prompts:</p>
<pre class="code-block tex2jax_ignore">rm: remove regular file 'newfile2.txt'?
rm: remove regular file 'newfile4.txt'?
rm: remove regular file 'newfile2_cp.txt'?
</pre>
<p>As you can see, regular expressions give you a lot of power and control.</p></section><span class="incontext"><a href="sec_dev_basic_shell_commands.html#paragraphs-14" class="internal">in-context</a></span>
</body>
</html>
